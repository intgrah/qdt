import Std.Bool
import Std.Eq
import Std.Nat
import Std.Option

inductive List (A : Type) where
  | nil
  | cons (head : A) (tail : List A)

def List.append (A : Type) (xs ys : List A) : List A := List.rec A (fun _ => List A) ys (fun h _ => List.cons A h) xs
def List.map (A B : Type) (f : A → B) : List A → List B := List.rec A (fun _ => List B) (List.nil B) (fun h _ => List.cons B (f h))
def List.all (A : Type) (p : A → Bool) : List A → Bool := List.rec A (fun _ => Bool) Bool.true (fun h _ => Bool.and (p h))
def List.any (A : Type) (p : A → Bool) : List A → Bool := List.rec A (fun _ => Bool) Bool.false (fun h _ => Bool.or (p h))

def List.foldr (A B : Type) (f : A → B → B) (z : B) : List A → B := List.rec A (fun _ => B) z (fun h _ => f h)
def List.foldl (A B : Type) (f : B → A → B) (z : B) (xs : List A) : B := List.rec A (fun _ => B → B) (fun acc => acc) (fun h _ ih acc => ih (f acc h)) xs z
def List.filter (A : Type) (p : A → Bool) : List A → List A := List.rec A (fun _ => List A) (List.nil A) (fun h t ih => Bool.ite (List A) (p h) (List.cons A h ih) ih)
def List.filterMap (A B : Type) (f : A → Option B) : List A → List B := List.rec A (fun _ => List B) (List.nil B) (fun h t ih => Option.rec B (fun _ => List B) (List.nil B) (fun b => List.cons B b ih) (f h))

def List.flatten (A : Type) : List (List A) → List A := List.rec (List A) (fun _ => List A) (List.nil A) (fun xs _ => List.append A xs)
def List.flatMap (A B : Type) (f : A → List B) (xs : List A) : List B := List.flatten B (List.map A (List B) f xs)

def List.length (A : Type) : List A → Nat := List.rec A (fun _ => Nat) Nat.zero (fun _ _ => Nat.succ)

def List.length_append (A : Type) (xs ys : List A)
    : List.length A (List.append A xs ys) = Nat.add (List.length A xs) (List.length A ys) :=
  List.rec A
    (fun zs => List.length A (List.append A zs ys) = Nat.add (List.length A zs) (List.length A ys))
    (Eq.symm Nat (Nat.add Nat.zero (List.length A ys)) (List.length A ys) (Nat.zero_add (List.length A ys)))
    (fun h t ih =>
      Eq.trans Nat
        (Nat.succ (List.length A (List.append A t ys)))
        (Nat.succ (Nat.add (List.length A t) (List.length A ys)))
        (Nat.add (Nat.succ (List.length A t)) (List.length A ys))
        (congr_arg Nat Nat Nat.succ (List.length A (List.append A t ys)) (Nat.add (List.length A t) (List.length A ys)) ih)
        (Eq.symm Nat (Nat.add (Nat.succ (List.length A t)) (List.length A ys)) (Nat.succ (Nat.add (List.length A t) (List.length A ys))) (Nat.succ_add (List.length A t) (List.length A ys))))
    xs

inductive List.Mem (A : Type) (a : A) : List A → Type where
  | head (as : List A) : List.Mem A a (List.cons A a as)
  | tail (b : A) (as : List A) : List.Mem A a as → List.Mem A a (List.cons A b as)

inductive List.Perm (A : Type) : List A → List A → Type where
  | nil : List.Perm A (List.nil A) (List.nil A)
  | cons (x : A) (l1 l2 : List A) : List.Perm A l1 l2 → List.Perm A (List.cons A x l1) (List.cons A x l2)
  | swap (x y : A) (l : List A) : List.Perm A (List.cons A y (List.cons A x l)) (List.cons A x (List.cons A y l))
  | trans (l1 l2 l3 : List A) : List.Perm A l1 l2 → List.Perm A l2 l3 → List.Perm A l1 l3

inductive List.Sublist (A : Type) : List A → List A → Type where
  | slnil : List.Sublist A (List.nil A) (List.nil A)
  | cons (a : A) (l1 l2 : List A) : List.Sublist A l1 l2 → List.Sublist A l1 (List.cons A a l2)
  | cons2 (a : A) (l1 l2 : List A) : List.Sublist A l1 l2 → List.Sublist A (List.cons A a l1) (List.cons A a l2)

inductive Forall2 (A B : Type) (R : A → B → Type) : List A → List B → Type where
  | nil : Forall2 A B R (List.nil A) (List.nil B)
  | cons (a : A) (b : B) (as : List A) (bs : List B) : R a b → Forall2 A B R as bs → Forall2 A B R (List.cons A a as) (List.cons B b bs)

inductive SublistForall2 (A B : Type) (R : A → B → Type) : List A → List B → Type where
  | nil (l : List B) : SublistForall2 A B R (List.nil A) l
  | cons (a : A) (b : B) (l1 : List A) (l2 : List B) : R a b → SublistForall2 A B R l1 l2 → SublistForall2 A B R (List.cons A a l1) (List.cons B b l2)
  | cons_right (b : B) (l1 : List A) (l2 : List B) : SublistForall2 A B R l1 l2 → SublistForall2 A B R l1 (List.cons B b l2)

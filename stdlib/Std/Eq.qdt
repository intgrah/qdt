inductive Eq.{u} (A : Type u) (a : A) : A → Type u where
  | refl : Eq A a a

-- UIP
axiom Eq.ext.{u} (A : Type u) (x y : A) (p q : x = y) : p = q

def Eq.ndrec.{v, u} (A : Type u) (a : A) (motive : A → Type v) (h : motive a) (b : A) (p : a = b) : motive b :=
  Eq.rec.{v, u} A a (fun x _ => motive x) h b p

def Eq.subst.{v, u} (A : Type u) (P : A → Type v) (a b : A) (p : a = b) (h : P a) : P b :=
  Eq.ndrec.{v, u} A a P h b p

def Eq.symm.{u} (A : Type u) (a b : A) (p : Eq.{u} A a b) : Eq.{u} A b a :=
  Eq.subst.{u, u} A (fun y => Eq.{u} A y a) a b p (Eq.refl.{u} A a)

def Eq.trans.{u} (A : Type u) (a b c : A) (p : Eq.{u} A a b) (q : Eq.{u} A b c) : Eq.{u} A a c :=
  Eq.subst.{u, u} A (fun z => Eq.{u} A a z) b c q p

def congrArg.{u, v} (A : Type u) (B : Type v) (f : A → B) (x y : A) (p : Eq.{u} A x y) : Eq.{v} B (f x) (f y) :=
  Eq.subst.{v, u} A (fun z => Eq.{v} B (f x) (f z)) x y p (Eq.refl.{v} B (f x))

def congrFun.{u, v} (A : Type u) (B : A → Type v) (f g : (x : A) → B x) (p : Eq.{max u v} ((x : A) → B x) f g) (x : A) : Eq.{v} (B x) (f x) (g x) :=
  Eq.subst.{v, max u v} ((x : A) → B x) (fun h => Eq.{v} (B x) (f x) (h x)) f g p (Eq.refl.{v} (B x) (f x))

inductive Eq (A : Type) (a : A) : A → Type where
  | refl : Eq A a a

-- UIP
axiom Eq.ext (A : Type) (x y : A) (p q : x = y) : p = q

def Eq.ndrec (A : Type) (a : A) (motive : A → Type) (h : motive a) (b : A) (p : a = b) : motive b :=
  Eq.rec A a (fun x _ => motive x) h b p

def Eq.subst (A : Type) (P : A → Type) (a b : A) (p : a = b) (h : P a) : P b :=
  Eq.ndrec A a P h b p

def Eq.symm (A : Type) (a b : A) (p : a = b) : b = a :=
  Eq.subst A (fun y => y = a) a b p (Eq.refl A a)

def Eq.trans (A : Type) (a b c : A) (p : a = b) (q : b = c) : a = c :=
  Eq.subst A (fun z => a = z) b c q p

def congrArg (A B : Type) (f : A → B) (x y : A) (p : x = y) : f x = f y :=
  Eq.subst A (fun z => f x = f z) x y p (Eq.refl B (f x))

def congrFun (A B : Type) (f g : A → B) (p : f = g) (x : A) : f x = g x :=
  Eq.subst (A → B) (fun h => f x = h x) f g p (Eq.refl B (f x))

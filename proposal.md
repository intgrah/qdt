# Query-based Incremental Elaborator for a Dependently Typed Language

## Introduction and Description

This project aims to implement an incremental, query-based elaborator for a dependently typed toy language, for efficient type checking in interactive development environments, such as proof assistants. Traditional type checkers for dependent types operate in batch mode, re-checking entire programs after each change. This project will investigate query-based compilation techniques, building on Olle Fredriksson's work and modern language servers, to enable efficient incremental type checking.

The core objective is to build an elaborator that can efficiently respond to local changes in source code by recomputing only the affected parts of the type checking process. This will be achieved using a query-based architecture where type checking operations are decomposed into memoisable queries with explicit dependencies. The implementation will use the Salsa framework, written in Rust, which provides the tools for incremental on-demand computation by automatically tracking dependencies and memoisation.

## Starting Point

No prior work was done before October.

## Substance and Structure

1. Core Language: a minimal dependently typed calculus with Pi, universes, and basic inductive types. The syntax will support function definitions, pattern matching, and type annotations.
2. Query-based elaborator: bidirectional type checking decomposed into queries (e.g., `infer_type`, `check_type`, `normalise_term`). Each query can be memoised, with proper dependency tracking to enable incremental recomputation.
3. Incremental infrastructure: use of the Salsa framework to handle source file changes, manage parse trees, and dependency graphs for queries. Detection of changes and lazy memoisation strategies. This is the most important component of the project.
4. Performance evaluation framework: benchmarking suite to measure incremental performance against batch re-elaboration, including synthetic workloads simulating typical editing patterns.

Key algorithms include type unification, bidirectional type checking with constraint generation, normalisation for dependent types.

## Success Criteria and Evaluation Plan

### Success Criteria

1. Correctly type check a language with dependent types, including Pi types, Sigma types and inductive types
2. Demonstrate measurable performance improvement for incremental changes vs full re-elaboration

### Evaluation Plan

- Correctness: test suite of programs including simple proofs of equality, existential and universal quantification (dependent pair and arrow types).
- Performance and scalability: Benchmarks measuring re-elaboration time for:
  - local definition changes
  - type signature modifications
  - cascading dependency updates
    on sample programs, generated by a computer, of at least 1000 lines of code

## Work Plan

### Michaelmas Term

- 9 Oct - 22 Oct: Read Salsa documentation, study dependent type implementation, implement toy examples, design language syntax and semantics
- 23 Oct - 6 Nov: Implement elaborator for dependent types over a query-based interface
- 7 Nov - 19 Nov: Complete elaborator for dependent types, including identity types, dependent pairs; write example programs
- 20 Nov - 3 Dec: Decompose elaborator, and other stages of compilation process into fine-grained queries

### Lent Term

- 22 Jan - 4 Feb: Implement incrementalisation with change detection, cache invalidation, and dependency tracking, utilising Salsa
- 5 Feb - 18 Feb: Complete incrementalisation, with source-based tracking
- 19 Feb - 4 Mar: Optimise incrementalisation, query granularity and dependency tracking
- 5 Mar - 18 Mar: Evaluation and performance benchmarks, with synthetic programs

### Easter Term

- 30 Apr - 15 May: Dissertation

## Resources Declaration

- Personal laptop (32 GB RAM, Intel Ultra 7 155) for development
- Backup strategy: Git repository on GitHub
- Contingency plan: Backup laptop available

## Ethics Approval

Not required as no human participants or personal data involved.

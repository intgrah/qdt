import Std.Eq

inductive Nat where
  | zero
  | succ (n : Nat)

def Nat.one   := Nat.succ Nat.zero
def Nat.two   := Nat.succ Nat.one
def Nat.three := Nat.succ Nat.two
def Nat.four  := Nat.succ Nat.three
def Nat.five  := Nat.succ Nat.four
def Nat.six   := Nat.succ Nat.five

def Nat.add (m n : Nat) : Nat :=
  Nat.rec (fun _ => Nat) m (fun _ ih => Nat.succ ih) n

def Nat.mul (m n : Nat) : Nat :=
  Nat.rec (fun _ => Nat) Nat.zero (fun _ ih => Nat.add m ih) n

inductive Nat.le (n : Nat) : Nat -> Type where
  | refl : Nat.le n n
  | step (m : Nat) (p : Nat.le n m) : Nat.le n (Nat.succ m)

def Nat.zero_le (n : Nat) : Nat.le Nat.zero n :=
  Nat.rec (fun m => Nat.le Nat.zero m)
    (Nat.le.refl Nat.zero)
    (fun m ih => Nat.le.step Nat.zero m ih)
    n

def Nat.lt (m : Nat) := Nat.le (Nat.succ m)

def Nat.factorial : Nat -> Nat :=
  Nat.rec (fun _ => Nat) (Nat.succ Nat.zero) (fun k ih => Nat.mul (Nat.succ k) ih)

example : Eq Nat (Nat.factorial Nat.three) Nat.six := Eq.refl Nat Nat.six

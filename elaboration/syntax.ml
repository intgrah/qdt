(* ========== Raw Syntax ========== *)

module Raw = struct
  type t =
    | Ident of string (* x *)
    | App of t * t (* a b *)
    | Lam of binder list * t (* fun x y : T => e *)
    | Pi of binder_group * t (* (x y : A) → B *)
    | Arrow of t * t (* A → B *)
    | Let of string * t option * t * t (* let x : A := a; b *)
    | U (* Type *)
    | Unit (* Unit *)
    | UnitTm (* () *)
    | Empty (* Empty *)
    | Absurd of t (* absurd a *)
    | Eq of t * t (* a = b *)
    | Refl of t (* refl a *)
    | Sigma of binder_group * t (* (x y : A) × B *)
    | Prod of t * t (* A × B *)
    | Pair of t * t (* (a, b) *)
    | Proj1 of t (* fst e *)
    | Proj2 of t (* fst e *)
    | Int (* Int *)
    | IntLit of int (* 0 *)
    | Add of t * t (* a + b *)
    | Sub of t * t (* a - b *)
    | Ann of t * t (* generated by defs *)
    | Sorry (* sorry *)

  and binder = string option * t option
  and binder_group = string option list * t

  type item =
    | Def of string * t
    | Example of t

  type program = item list
end

(* ========== Core Syntax ========== *)

module Idx = struct
  type t = Idx of int

  let to_int (Idx l) = l
end

module Lvl = struct
  type t = Lvl of int

  let to_int (Lvl l) = l
end

type ty =
  | TyU
  | TyPi of string option * ty * ty
  | TySigma of string option * ty * ty
  | TyUnit
  | TyEmpty
  | TyInt
  | TyEq of tm * tm * ty
  | TyEl of tm

and tm =
  | TmVar of Idx.t
  | TmConst of string (* global constant *)
  | TmLam of string option * ty * tm
  | TmApp of tm * tm
  | TmPiHat of string option * tm * tm
  | TmSigmaHat of string option * tm * tm
  | TmMkSigma of ty * ty * tm * tm
  | TmProj1 of tm
  | TmProj2 of tm
  | TmUnit
  | TmAbsurd of ty * tm
  | TmIntLit of int
  | TmUnitHat
  | TmEmptyHat
  | TmIntHat
  | TmEqHat of tm * tm * ty
  | TmRefl of ty * tm
  | TmAdd of tm * tm
  | TmSub of tm * tm
  | TmSorry of int * ty
  | TmLet of string * ty * tm * tm

(* Weak head normal form *)
type vl_ty =
  | VTyU
  | VTyPi of string option * vl_ty * clos_ty
  | VTySigma of string option * vl_ty * clos_ty
  | VTyUnit
  | VTyEmpty
  | VTyInt
  | VTyEq of vl_tm * vl_tm * vl_ty
  | VTyEl of neutral

(* Weak head normal form *)
and vl_tm =
  | VTmNeutral of neutral
  | VTmLam of string option * vl_ty * clos_tm
  | VTmPiHat of string option * vl_tm * clos_tm
  | VTmSigmaHat of string option * vl_tm * clos_tm
  | VTmMkSigma of string option * vl_ty * clos_ty * vl_tm * vl_tm
  | VTmUnit
  | VTmIntLit of int
  | VTmUnitHat
  | VTmEmptyHat
  | VTmIntHat
  | VTmEqHat of vl_tm * vl_tm * vl_ty
  | VTmRefl of vl_ty * vl_tm
  | VTmAdd of vl_tm * vl_tm
  | VTmSub of vl_tm * vl_tm

and neutral = head * spine

and head =
  | HVar of Lvl.t (* de Bruijn level *)
  | HConst of string
  | HSorry of int * vl_ty

and spine = fname list

and fname =
  | FApp of vl_tm
  | FProj1
  | FProj2
  | FAbsurd of vl_ty

and clos_ty = ClosTy of env * ty
and clos_tm = ClosTm of env * tm
and env = vl_tm list

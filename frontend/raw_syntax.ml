type t =
  | Ident of string (* x *)
  | App of t * t (* a b *)
  | Lam of binder list * t (* fun x y : T => e *)
  | Pi of binder_group * t (* (x y : A) → B *)
  | Arrow of t * t (* A → B *)
  | Let of string * t option * t * t (* let x : A := a; b *)
  | U (* Type *)
  | Sigma of binder_group * t (* (x y : A) × B *)
  | Prod of t * t (* A × B *)
  | Pair of t * t (* (a, b) *)
  | Eq of t * t (* a = b, desugars to Eq _ a b *)
  | NatLit of int (* 0 *)
  | Add of t * t (* a + b *)
  | Sub of t * t (* a - b *)
  | Ann of t * t (* generated by defs *)
  | Sorry (* sorry *)

and binder = string option * t option
and binder_group = string option list * t

type field = {
  name : string;
  binders : binder_group list;
  ty : t;
}

type constructor = {
  name : string;
  params : binder list;
  ty : t option;
}

type item =
  | Import of { module_name : string } (* import Foo.Bar *)
  | Def of {
      name : string;
      body : t;
    }
  | Example of { body : t }
  | Inductive of {
      name : string;
      params : binder_group list;
      ty : t option;
      ctors : constructor list;
    }
  | Structure of {
      name : string;
      params : binder_group list;
      ty : t option; (* optional result type annotation, always Type *)
      fields : field list;
    }

type program = item list

inductive Nat where
  | zero
  | succ (n : Nat)

inductive List (A : Type) where
  | nil
  | cons (head : A) (tail : List A)

def Nat.add (m n : Nat) : Nat :=
  Nat.rec (fun _ => Nat) m (fun _ ih => Nat.succ ih) n

def List.map (A B : Type) (f : A → B) : List A → List B :=
  List.rec A (fun _ => List B) (List.nil B) (fun h _ ih => List.cons B (f h) ih)

def List.length (A : Type) : List A → Nat :=
  List.rec A (fun _ => Nat) Nat.zero (fun _ _ ih => Nat.succ ih)

inductive LE (n : Nat) : Nat → Type where
  | refl : LE n n
  | step (m : Nat) (p : LE n m) : LE n (Nat.succ m)

def LE.trans (a b c : Nat) (hab : LE a b) (hbc : LE b c) : LE a c :=
  LE.rec b (fun k _ => LE a k) hab (fun m _ ih => LE.step a m ih) c hbc
